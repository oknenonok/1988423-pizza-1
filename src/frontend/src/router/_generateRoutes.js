/**
 * Плагин для Webpack, генерирует файл routes.js с массивом роутов на основании информации из .vue файлов в каталоге views
 */
const { parse: componentParse } = require("@vue/component-compiler-utils");
const { readFileSync, readdirSync, writeFileSync } = require("fs");
const compiler = require("vue-template-compiler");
const ts = require("typescript");
const { parse: JSParse } = require("acorn");

const EXTRACT_FIELDS = ["title", "layout", "middlewares"];

/**
 * Вытащить нужные параметры из vue-скрипта
 * @param {string} fileName
 * @returns {object}
 */
const parseFile = (fileName) => {
  const result = { name: fileName.replace(/^Page(.*)\.vue$/, "$1") };
  try {
    const source = readFileSync(`${__dirname}/../views/${fileName}`, "utf8");
    const parsedVue = componentParse({
      source,
      compiler,
      needMap: false,
    });

    const transpiledCode = ts.transpileModule(
      parsedVue.script.content,
      {}
    ).outputText;

    const parsed = JSParse(transpiledCode, {
      sourceType: "module",
      ecmaVersion: 2020,
    });

    const exportDefault = parsed.body.find((node) => {
      return (
        node.type === "VariableDeclaration" &&
        node.declarations[0].id.name === `Page${result.name}`
      );
    });

    exportDefault.declarations[0].init.callee.body.body.forEach((node) => {
      if (node.type == "FunctionDeclaration") {
        node.body.body.forEach((subnode) => {
          if (subnode.type === "ExpressionStatement") {
            let propName = subnode.expression.left.property.name;
            if (EXTRACT_FIELDS.includes(propName)) {
              result[propName] =
                subnode.expression.right.type === "ArrayExpression"
                  ? subnode.expression.right.elements.map(
                      (arrNode) => arrNode.name
                    )
                  : subnode.expression.right.raw;
            }
          }
        });
      }
    });
  } catch (e) {
    console.error(e);
  }
  return result;
};

/**
 * Получить массив всех используемых middlewares
 * @param {array} options
 * @returns {array}
 */
const getUsedMiddlewares = (options) => {
  return [
    ...new Set(
      options
        .map((option) => option.middlewares)
        .filter((option) => option)
        .reduce((middlewares, result) => result.concat(middlewares), [])
    ),
  ];
};

/**
 * Сгенерировать текст скрипта с роутами
 * @param {array} options
 * @returns {string}
 */
const generateScript = (options) => {
  const middlewaresImports = getUsedMiddlewares(options).join(", ");
  return (
    `// This file was autogenerated by _generateRoutes script
import getView from "@/common/helpers/getView";` +
    (middlewaresImports
      ? `
import { ${middlewaresImports} } from "@/middlewares";`
      : "") +
    `
import { RouteConfig } from "vue-router";

const routes: RouteConfig[] = [` +
    options
      .map(
        ({ name, layout, middlewares, title }) =>
          `
  {
    path: "/${name === "Index" ? "" : name.toLowerCase()}",
    name: "${name}",
    component: getView("${name}"),
    meta: {` +
          (layout
            ? `
      layout: ${layout},`
            : "") +
          (middlewares
            ? `
      middlewares: [${middlewares.join(", ")}],`
            : "") +
          (title
            ? `
      title: ${title},`
            : "") +
          `
    },
  }`
      )
      .join(",\n") +
    `,
];
export default routes;
`
  );
};

/**
 * Сгенерировать файл с роутами
 */
const generateRoutesFile = () => {
  const options = [];
  readdirSync(__dirname + "/../views").forEach((file) => {
    if (file.startsWith("Page") && file.endsWith(".vue")) {
      options.push(parseFile(file));
    }
  });
  let newContent = generateScript(options);
  if ("" + readFileSync(`${__dirname}/routes.ts`) !== newContent) {
    writeFileSync(`${__dirname}/routes.ts`, newContent);
  }
};

module.exports = class GenerateRoutesPlugin {
  apply(compiler) {
    compiler.hooks.compile.tap({ name: "GenerateRoutes" }, generateRoutesFile);
  }
};
